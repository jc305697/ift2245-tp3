\documentclass{article}

\usepackage[utf8]{inputenc}
\setlength{\parskip}{1em}%https://www.sharelatex.com/learn/Paragraph_formatting%
\setlength{\parindent}{0em}
\title{Travail pratique \#3 - IFT-2245}
\author{Maude Sabourin et Jérémy Coulombe}

\begin{document}

\maketitle

\section{Expérience}
Durant ce travail qui semblait si simple, nous avons été confronté à plusieurs surprises innatendues. Par exemple, nous nous sommes rendus compte que nous ne gérions pas le cas d'une écriture sur une page qui est en readonly. Par la suite, nous avons essayer d'implanter le copy on write pour nous rendre compte que notre algorithme pour trouver le frame qui a été utilisé le moins récemment ne retournait que le numéro du frame donc nous avons dû modifier celui-ci afin de gérer ce cas pour se rendre compte que ça nous donnait de très mauvais résultat au niveau du tlb miss rate. Nous avons du faire quelques modifications afin d'obtenir un taux de raté pour le tlb inférieur à celui que nous obtenions précedemment.

\section {Difficultés}
Nous avons rencontrées plusiseurs  problèmes. Nous avions au déput fait une implémentation d'un algorithme LRU, mais celle-ci connaissait certains problèmes au niveau de l'imlpantation qui ne pouvait être résolu que par une modification en profondeur de l'implantation. Nous avons donc choisi de faire une autre implantation d'un algortithme LRU qui après une bonne séance de déboguage celle- ci fonctionnait comme elle était censé  le faire ce qui nous a permis de nous attaquer à un problème que nous avions perdu de vue soit l'écriture sur un frame qui est en "view-only".
\par
 Bien qu'il est de notre avis que les consignes sont floues à ce sujet nous avons juger qu'il serait pertinent d'utiliser une stratégie basé sur le principe du copy on write et ce dans les limites que nous impose notre implémentation et dans un cadre plus général les limites du projet.  Nous avons eu des problèmes avec l'implémentation du "copy on write" qui est inclus entre la spécification du statut des pages. Par exemple, nous nous sommes rendus compte que nous ne possédions pas les informations nécessaires avec notre implémentation du LRU pour faire l'allocation des frames aux pages logiques donc nous avons dû modifier notre algorithme afin qu'il travaille avec des struct au lieu de unsigned int.  Nous avons par la suite du séparer une de nos fonction en 3 fonctions séparés afin de pouvoir implanter un version crédible de "copy on write" et d'éviter une redondance de code.  
\par

Par la suite nous nous sommes rendu compte que lorsque nous écrivions dans le backing store nous écrivions des caractères null ce qui faisait en sorte que le fichier texte devenait instable. 
\par
Nous avons aussi eu des problèmes lorsque nous avons tenté d'essayer d'implanter un générateur d'opérations avec des adresses générés aléatoirement afin de pouvoir tester notre programme sur un nombre d'accès conséquent. 
\par
Nous ne pouvions plus à un certain moment déboguer à l'aide d'impression sur la ligne de commande pour une raison qui nous reste encore inconnue à ce jour ce qui semble être une tendance lorsque nous travaillons en C. 
\par
Nous avons aussi  eu des problèmes qui étaient causé par de petites erreurs, mais qui nous ont pris du temps à trouver la source de ces erreurs. Par exemple, nous avions un if qui avait comme condition qu'un unsigned integer soirt < 0 ce qui bien sûre n'arrivait jamais.
\par
%Unsigned Integer : Comparaison, problématique
%Commandes de style fseek, fwrite, fread, fputs
%Bien été
%Memset, commence à être habitué
%Strncpy
%Algorithme
%Au début : implémentation liste 
%Un peu compliqué  et  coûteux de toujours déplacer tous les éléments
%Ensuite implémentation binaire, shift
%Comment gérer l’ajout : utilisation du 100000000 pour 64 bits 
%Même algo LRU et PT
%Bons rendements
%Implémentation copy on write et gestion readonly

\section{Résultats}
Notre algorithme obtient des résultalts relativement satisfaisant.

\section{Algo et choix implantés}
Nous avons décider d'essayer de faire une implémentation qui serait la plus réaliste possible donc nous avons fait en sorte que nous ne copions le contenu des frames que lorsque nous aurions écris sur ceux-ci donc lorsque ceux-ci sont dirty afin de faire en sorte de minimmiser le nombre d'IO operation au total puisque ces dernières sont les opérations les plus coûteuses sur les systèmes réels. 
\par
Nous avons aussi choisi de faire un algorithme pour les écritures sur les frames qui sont readonly qui s'inspire du "copy on write" afin d'avoir une implémentation la plus proche de la réalité que possible même si ça nous a apporté plusieurs difficultés comme mentionné  plus haut dans ce rapport et que ça a un certain impact sur les performances de notre implentation.
\par 
Nous avions au début décidé d'implanté un algortihme LRU qui servait d'une liste qui se trouvait dans un tableau, mais nous avons décidé d'abandonner cette idée après avoir rencontré des difficultés comme mentionné dans la section portant sur celles-ci, mais un autre facteur ayant pesé dans notre décision fut le coût de déplacer plusieurs éléments dans un tableau à chaque accès au tlb ou à un frame pour ce qui est le cas du gestionnaire de la mémoire virtuelle (vmm). Nous avons décidé d'utiliser le même principe d'algortihme pour le choix des frames dans le tlb et le vmm quoi que chacun à ses particularités dans son  implémentation.  Ces algorithmes nous ont permis d'obtenir de bons rendements que ce soit par exemple au niveau des tlb hits.
\section{Améliorations possibles}
Nous pourrions implanter une table de page multi-niveau ou nous pourrions implanter de manière plus réaliste le "copy on write". Il serait aussi intéressant de gérer plusieurs tables de pages soit une pour chaque processus fictif afin d'avoir une implentation qui se rapproche encore plus de la réalité.

\section{Fonctionnement du code}

Pour l'implémentation du "copy on write" nous allons obtenir un frame puis nous sauvegardons son contenu en mémoire. Par la suite nous allons chercher le contenu de la page sur laquelle nous voulionns écrire mais qui était read only puis nous téléchargeons le contenu de celle-ci dans le frame que nous avions obtenu puis nous allons modifier la table de page. Pour la sauvegarde en mémoire nous n'écrivons le contenu des frames en mémoires que s'ils ont été modifiées donc s'ils sont "dirty". 
\par 
Pour les algorithmes d'ordonnancement nous utilisons les bits shifts afin savoir qu'elle frame a la plus grande durées d'inutilisation depuis sa dernière utilisation.
\end{document}
