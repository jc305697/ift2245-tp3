\documentclass{article}

\usepackage[utf8]{inputenc}

\title{Travail pratique \#3 - IFT-2245}
\author{Maude Sabourin et Jérémy Coulombe}

\begin{document}

\maketitle

\section{Expérience}
Durant ce travail qui semblait si simple, nous avons été confronté à plusieurs surprises innatendues. Par exemple, nous nous sommes rendus compte que nous ne gérions pas le cas d'une écriture sur une page qui est en readonly. Par la suite, nous avons essayer d'implanter le copy on write pour nous rendre compte que notre algorithme pour trouver le frame qui a été utilisé le moins récemment ne retournait que le numéro du frame donc nous avons dû modifier celui-ci afin de gérer ce cas pour se rendre compte que ça nous donnait de très mauvais résultat au niveau du tlb miss rate. Nous avons du faire quelques modifications afin d'obtenir un taux de raté pour le tlb inférieur à celui que nous obtenions précedemment.

\section {Difficultés}
Nous avons rencontrées plusiseurs  problèmes. Nous avions au déput fait une implémentation d'un algorithme LRU, mais celle-ci connaissait certains problèmes au niveau de l'imlpantation qui ne pouvait être résolu que par une modification en profondeur de l'implantation. Nous avons donc choisi de faire une autre implantation d'un algortithme LRU qui après une bonne séance de déboguage celle- ci fonctionnait comme elle était censé  le faire ce qui nous a permis de nous attaquer à un problème que nous avions perdu de vue soit l'écriture sur un frame qui est en "view-only". Bien qu'il est de notre avis que les consignes sont floues à ce sujet nous avons juger qu'il serait pertinent d'utiliser une stratégie basé sur le principe du copy on write et ce dans les limites que nous impose notre implémentation et dans un cadre plus général les limites du projet.  Nous avons eu des problèmes avec l'implémentation du "copy on write" qui est inclus entre la spécification du statut des pages. Par exemple, nous nous sommes rendus compte que nous ne possédions pas les informations nécessaires avec notre implémentation du LRU pour faire l'allocation des frames aux pages logiques donc nous avons dû modifier notre algorithme afin qu'il travaille avec des struct au lieu de unsigned int.  Nous avons par la suite du séparer une de nos fonction en 3 fonctions séparés afin de pouvoir implanter un version crédible de "copy on write" et d'éviter une redondance de code.  Par la suite nous nous sommes rendu compte que lorsque nous écrivions dans le backing store nous écrivions des caractères null ce qui faisait en sorte que le fichier texte devenait instable. Nous avons aussi eu des problèmes lorsque nous avons tenté d'essayer d'implanter une générateur d'opérations avec des adresses générés aléatoirement afin de pouvoir tester notre programme sur un nombre d'accès conséquent. Nous ne pouvions plus à un certain moment déboguer à l'aide d'impression sur la ligne de commande pour une raison qui nous reste encore inconnue à ce jour ce qui semble être une tendance lorsque nous travaillons en C. Nous avons aussi 


Unsigned Integer : Comparaison, problématique
Commandes de style fseek, fwrite, fread, fputs

Bien été
Memset, commence à être habitué
Strncpy

Algorithme
Au début : implémentation liste 
Un peu compliqué  et  coûteux de toujours déplacer tous les éléments

Ensuite implémentation binaire, shift
Comment gérer l’ajout : utilisation du 100000000 pour 64 bits 
Même algo LRU et PT

Bons rendements

Implémentation copy on write et gestion readonly

\section{Résultats}


\section{Algo et choix implantés}
Backup juste si dirty
Copie on write baisse les perfos (plus réaliste)
\section{Améliorations possibles}


\section{Fonctionnement du code}

\end{document}
